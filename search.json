[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "MicroP Goals\n\n\nBroadly what I want to achieve from E155\n\n\n\n\n\nAug 29, 2025\n\n\nNoah Fotenos\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/proposal.html",
    "href": "project/proposal.html",
    "title": "Hardware Tetris Project Proposal",
    "section": "",
    "text": "Project Description and Overview\nOur project implements the classic game Tetris directly in hardware using an FPGA as the game engine and a microcontroller (MCU) as a peripheral co-processor. The FPGA handles core game logic and VGA display output, while the MCU manages higher-level logic such as random block generation and controller input translation.\nWe plan to leverage the FPGA for deterministic, processing of visual and game logic while using the MCU for tasks that benefit from flexibility, such as pseudo-random number generation and USB input handling.\nGameplay will be displayed on a VGA monitor at refresh rates exceeding 20 Hz with no flicker or ghosting. The FPGA’s internal memory will maintain the game state and render directly to VGA timing signals. The MCU will periodically supply the FPGA with new pieces and player inputs over a bus interface.\n\n\n\nFigure 1: Block Diagram with all electrical components\n\n\n\n\n\nProficiency Goals\n\nDisplay updates at &gt;20 Hz\n\nBlocks clear at completed lines and update correctly\n\nBlocks fall at standard rate\n\nNew random blocks appear once the previous block settles\n\nGame boundaries prevent invalid movement\n\nNo visibly obvious gameplay bugs\n\nPlayer can control piece movement with button input\n\nBlocks move left and right\n\n\n\n\nExcellency Goals\n\nGame speeds up progressively\n\nUSB controller used to play game\n\nBlock rotation implemented\n\nController operates in “arcade mode”\n\nHard drop implemented\n\nNext piece preview displayed\n\n\n\n\nFPGA Design Details\nThe FPGA implements a hardware Tetris engine consisting of the following modules:\n\nVGA Controller\nGenerates 800x600 @ 60 Hz timing signals and color data from block map memory.\n\n\nBlock Map Memory\nGame data stored in on-chip SRAM.\n\n\nPiece Logic\nDetermines piece movement, collision detection, and line clears for each frame.\n\n\nFSM Game Controller\nControls falling timing, piece locking, and score tracking.\n\n\nMCU Interface Module\nImplements a simple SPI interface to receive player inputs (left, right, rotate, drop) and new piece identifiers from the MCU.\n\n\nClocking & Timing\nUses a 80 MHz system clock for VGA synchronization and deterministic updates at &gt;20 Hz refresh rate.\n\n\n\n\nMCU Design Details\nThe MCU acts as an intelligent peripheral, responsible for higher-level coordination:\n\nRandom Piece Generation\nImplements a pseudo-random sequence ensuring fair block distribution.\n\n\nController Interface\nReads inputs from buttons or a USB gamepad and translates them into movement commands.\n\n\nCommunication Bridge\nUses SPI or UART to send player inputs and new-piece data to the FPGA.\n\n\nProgression Logic (Excellency)\nOptionally increases drop speed, handles “arcade mode,” and shows the “next piece” preview by pre-sending upcoming block data.\nA small task loop coordinates controller input polling and data buffering.\nAn interrupt will be used to request data from the MCU.\n\n\n\n\nBudget\n\n\n\nItem\nQuantity\nCost\nNotes\n\n\n\n\nVGA Breakout\n1×\n$14.26\nPurchased\n\n\nGameCube Controller\n1×\n$12.00\nPurchased\n\n\nTotal\n—\n$26.26\n\n\n\nSTM32 Nucleo-32 MCU\n1×\nHave\n\n\n\nUPduino iCE40 FPGA\n1×\nHave\n\n\n\n1000 ft Wire\n1×\nStockroom\n\n\n\nVGA Display\n1×\nBorrowed (Xavier)\n\n\n\n\n\n\n\nCalculations\n\nSVGA requires 40 MHz for 800×600.\nThe FPGA will divide the clock by 2 to achieve standard timing.\n\n\n\n\nSchedule\n\n\n\nWeek\nTask\nHours\nLead\n\n\n\n\n1 (Start 10/27)\nProject demo setup\n2 h\nBoth\n\n\n\nVGA implementation\n15 h +\nKaden\n\n\n\nMCU–FPGA link\n4 h +\nNoah\n\n\n2\nFPGA game shifter\n10 h +\nNoah\n\n\n\nMCU randomization + USB logic\n10 h +\nKaden\n\n\n3\nFinish game (Proficiency demo)\n3 h +\nBoth\n\n\n\nDemo presentation\n2 h +\nBoth\n\n\n4\nBegin Excellency work\n5 h +\nBoth\n\n\n5\nDebug\n10 h +\nBoth\n\n\n\nFinal presentation\n2 h +\nBoth\n\n\n\n\n\n\nWork Distribution\nWe plan on distributing work within each project aspect. Most of the time, we will work together in the lab; however, for aspects more appropriate for individual focus, we will assign tasks based on each member’s strengths and experience."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "MicroP Goals",
    "section": "",
    "text": "This semester my goal for E155 is deepen my knowledge in hardwear design. I have experience in digital design but feel like I havn’t been able to bring anything to the physical world. Additionally I am very excited for the final project and want to make something I can be really proad of."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab3",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nBuilding off lab2 7-Segment display circuit, The off board LED’s are replaced with the 4x4 matrix keypad with rows and outputs to and columns as inputs. Since the keyboard matrix works as switches connecting rows and columns to decode an input only one row can be powered at a time. Cycling through the rows waiting for a column input can be decoded for the specific key pressed. Once an input is detected a FSM as seen below is used to store the input, wait a period of about 100 ms to avoid D-bounce errors, wait for a release of the specific key ,and wait again for the release D-bounce.\n\n\n\nFigure 1: FSM design\n\n\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 160Hz to still be smooth to the eye without the display bleeding together while switching the row power fast enough to capture all inputs.\nTo test the design a Testbench for the 7-segment displays was already developed and tested in lab2.\nFirst checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Testbenches were made to check each submodule to very individual logic."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab3",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab3",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab3",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED’s without bleeding or visible oscillation or key-press glitches. This lab took around 15 hours."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab3",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file for the Monolithic design that did pass synthesis. I was super impressed by this because usually ai cant do large scale code. It did take longer than the past times but not by much at all. The code itself seems to use similiar high level logic to mine but the actual syntax is very different.\nThe modular prompts failed synthesis with many errors like unknown modules. So using the modular pompting I think the AI mixed its responses poorly. If I think both versions would require careful usage to work properly."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab5",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed calculate the RPM of a motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab5",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed calculate the RPM of a motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab5",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build uses header files from E-155 Git repository. This provided the macros and memory maps to use Flash, GPIO, USART, and RCC in the microcontroller. Pin A7 and A1 are set up as interrupt signals and the equations in figure 1 are used to calculate the RPS . Within the interrupt handlers first the signals of the motor encoder are checked then the signals are XOR’d to find the direction of the motor since for each encoder the XOR is either 1 or 0 depending on the relation to the other Encoder as seen in Figure 2. Depending on the direction the handler adds or subtracts a global counter to make show the # of edges. This gets converted to RPS.\nTo compare the ability of polling vs interrupts figure 3 shows the Osciliscope trace of a toggling pin from a polling loop. The frequency shows 600 hz but since this is alternating the actual polling as at 1.2 Khz. Using figure 4 the max RPM was calculated. To find the max interrups frequnecy a Frequency generator was connected to an interrupt pin and increased until behavior was incorrect."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab5",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab5",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully calculated the RPS of the motor. this lab took about 10 hours."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab5",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT did very well with this. It used PA0 and PA1 and essentially did everything within the interrupts with the same logic. However it used macros from an #include I don’t know to set up the interrups. I was suprrised about how much background information it provided as well as context for its ideas instead of just suppling the code."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab1",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nFor the hard wear the board was soldered in accordance to the E155 lab1 instructions. The resistor values for the 7-Segment display were derived from the Datasheet. Providing a 5v power supply from the board and a 2.1V drop across the diode with an If of 20mA using V=IR a resistor of 220ohms was used. For Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down so that the blinking frequency could be easily visualized using one of the on-board LEDs. The combinational logic for LED’s and 7-segment display were taking from the E155 specifications and truth table.\nTo test the design a Testbench was made to read a text file of test vectors describing all possible inputs and expected outputs. In simulation the Testbench reads the test file and compares to the DUT which is the top module implementing the above design. To confirm the oscillation an oscilloscope was used to show the frequency at which the LED is blinking."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab1",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab1",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab1",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator as well as displayed all Hexidecimal representation of a 4-bit input from onboard switches along with 2 gate controlled onboard LEDs. This lab took around 8 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab1",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was very fast to generate the entire Verilog module with “Internal HFOSC instantiation” and “Blink counter” code blocks. However the code failed do to miss instantiating the HFOSC writing “SB_HFOSC”. I was impressed that it went beyond the prompt and warned about if the led is pull down or not: “If your LED is active-low, just change the toggle line to led &lt;= ~led; starting from led = 1’b1;” I thought this was surprising since it went into implementation. It also asked if I wanted to generate a testbench to run in simulation. I was impressed less by the code it generated but how usefull it would be as a partner for a larger scale project to provide help and extra information."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED’s showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED’s showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab2",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe resistor values for the 7-Segment displays and external LED’s were derived 220 \\(\\Omega\\). This was found by taking the the input voltage 3.3V minus Vce_sat (.2V) from the PNP transister DataSheet minus the 2.1V voltage drop across the LED to get 1V/220 \\(\\Omega\\) to get 4.5mA which is within the FPGA safe current. The external LED’s just lack the PNP voltage drop so is (3.3-2.1)/220 \\(\\Omega\\) to get 5.4mA which is also safe.\nThe resister for the PNP transister was picked targeting a 7.4mA from a 3.3v minus the Vbe_sat saturation voltage from base to emitter .85V to get 2.45V/330 \\(\\Omega\\) to be enough to activate the transister and be safe for the FPGA\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 80Hz to be inviable to the eye without the display bleeding together.\nTo test the design a Testbench for the 7-segment display was already developed and tested in lab1. Another Testbench was used to verify the counter module for the internal oscillator using assert statements checking the reset low pushes 0 into the counter as well as on the first clock the correct 28 is added to the counter, then waiting for the most significant bit to go high when anticipated. The top level module also uses assert statements to confirm all components work as intended. First checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Then to confirm the oscillation period waiting the half period of 3.125*e^9 pico seconds to confirm the 8Hz frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab2",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab2",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED’s and sum LEDs without bleeding or visible oscillation. There was a strange bug that with a specific combination of pins were set the led would get disrupted even though the logic was sound and was fixed with a capacitor to one of the I/O pins. If I had more time I would like to find the true source of this bug. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab2",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file but had difficulty calling the other modules correctly. To me the code it generated was much more complicated than it needed to be using syntax I am unfamiliar with. The code is logically sound after inspection but did not synthesize first try. I think if I were to work with this code for a bit I could get it working much faster than it took me."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab4",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build largely based off of the starter code from from the E-155 Git repository. This provided the macros and memory maps to use Flash, GPIO, and RCC in the microntroller. To utilize TIM15 and TIM16 a header-file with the register map layout at the correct memory was made to reference and active the proper outputs. To get notes to play 3 function were made en15_16_APB(), wait and PWM. The en15_16_APB() functions instantiates the needed path so TIM15 and TIM16 get the system clock at 80Mhz. The wait function using TIM15 is used for the duration of notes or pauses and utilizes the a set prescaler at 799 to divide the clock to 1000hz then sets the ARR register value to the inputed milliseconds times 100 to be in the right unit of hertz. There is a while loop waiting for the ARR overflow bit is set once the wait time has past. The PWM function sets TIM16 to a desired frequency. It does this by first cheking if the frequency is 0 to freeze the system and avoid divide by 0 issues. Then divides 80Mhz by the desired frequency into a temp variable to see if only ARR is needed if the value is to large past the 16 bit register size it divides the temp variable by 2 and multiplies the prescaler by 2 until it can fit into ARR. The main function instatiates the all the macros and houses the song frequency and duration tables. The main function then goes through the table inputing into the wait and PWM function to play the songs.\nTo test the system calculations for maximum and minimum frequency and wait times were calculated as well as the expected error in output frequency as seen below."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab4",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab4",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully played Fur Elise and the ice cream truck song. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab4",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT Chose to use TIM2 instead of TIM15 TIM16. The calculations all looked good. The registers it chose look correct although I didn’t use TIM2. I am surprised how well it responded with needed info. I also asked it for code which it did, it seems like the the register instantiation looked good but I didn’t try uploading it."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Noah Fotenos is a Junior at Harvey Mudd College majoring in Engineering."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to E155 Website"
  }
]