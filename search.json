[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "MicroP Goals\n\n\nBroadly what I want to achieve from E155\n\n\n\n\n\nAug 29, 2025\n\n\nNoah Fotenos\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html",
    "href": "E155-Portfolio/portfolio/portfolio.html",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "",
    "text": "This project implements a complete Tetris game system using a dedicated microcontroller (MCU) and an FPGA working together over a well-defined hardware interface. The FPGA implements the real-time game logic and VGA video pipeline, while the MCU provides hardware random number generation and a control channel for the game. The final system drives a VGA display at 640√ó480@60 Hz, accepts input from a PS/2 keyboard, and renders a flicker-free Tetris game with proper line clears and loss detection.\nThe main goals of this project were to:\n\nDemonstrate hardware/software co-design using a discrete MCU and FPGA.\nImplement a fully hardware Tetris pipeline on the FPGA with clean, parameterized RTL.\nMeet real-time display and responsiveness requirements (&gt;~20 Hz update, no visible flicker or ghosting).\nExtend the course reference designs with new hardware modules including on board MCU entropy-based randomization and FPGA PLL module."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#system-overview",
    "href": "E155-Portfolio/portfolio/portfolio.html#system-overview",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "System Overview",
    "text": "System Overview\nAt a high level, the system consists of:\n\nA microcontroller (MCU) responsible for:\n\nGenerating hardware random numbers used to select new Tetris pieces.\nSending configuration and Keyboard commands over SPI.\n\nAn FPGA responsible for:\n\nVGA timing generation at 640√ó480@60 Hz using an on-chip PLL.\nTetris game state (piece movement, rotation, collision detection, line clears, scoring).\nTelemetry overlay and debug visualization on top of the game board.\n\n\nCommunication between the MCU and FPGA uses a custom SPI-based protocol, with the MCU as master. The FPGA exposes memory-mapped registers for commands, random-number injection."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#microcontroller-design-overview",
    "href": "E155-Portfolio/portfolio/portfolio.html#microcontroller-design-overview",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Microcontroller Design Overview",
    "text": "Microcontroller Design Overview\nThe microcontroller acts as a control and randomness front-end for the FPGA:\n\nHardware Random Source The MCU uses its on-chip hardware RNG (or a pseudorandom generator seeded by a hardware source, depending on the specific device) to generate random values that select the next Tetris piece type and orientation. This prevents predictable piece sequences and keeps gameplay fair.\nSPI Command/Status Channel The MCU is the SPI master, periodically transmitting:\n\nNew random seeds or piece IDs.\nReceives and decodes USART PS/2 inputs from keyboard interrupts.\nSends random seed and keyboard input over SPI to FPGA\n\n\nOn the STM32L432KC we use the built-in true random number generator (RNG) peripheral instead of a software pseudo-random generator. This hardware block continuously produces 32-bit entropy samples derived from an analog noise source inside the chip. In our firmware, we enable and configure the RNG once at startup, then each time the game needs randomness we read a fresh 32-bit word, compress it down to a 3-bit value (g_random3), and pack that into the SPI word sent to the FPGA along with the keyboard state. The FPGA then uses those 3 random bits to drive Tetris gameplay randomness (for example, piece selection), while the MCU handles all interaction with the RNG hardware.\nThe RNG peripheral is designed as a live entropy source suitable for building NIST-compliant deterministic random bit generators (DRBGs). In our project, we use it directly as a high-quality entropy source, which means each game session gets a genuinely non-repeatable sequence of pieces without us having to manage seeding or maintain a software RNG state.\nThe SPI protocol is hardware-friendly: fixed-width frames with an opcode, optional payload, and parity/error-check bits. whenever the MCU sends a game update to the FPGA over SPI, it packs these three random bits into the same SPI word that carries the current keyboard state. On the FPGA, that 3-bit field is decoded and used to drive Tetris gameplay randomness (for example, piece selection or spawn behavior). Keeping the random logic on the MCU lets us change or debug the RNG algorithm entirely in C without touching the Verilog design, while still delivering compact, timing-friendly random signals to the FPGA each frame."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#fpga-design-overview",
    "href": "E155-Portfolio/portfolio/portfolio.html#fpga-design-overview",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "FPGA Design Overview",
    "text": "FPGA Design Overview\nThe FPGA implements all real-time, cycle-accurate tasks in the system:\n\nClocking and PLL\nAn on-chip PLL generates the required pixel clock for 640√ó480@60 Hz VGA from the internal high-speed oscillator. VGA timing is synchronized to this clock domain. The rest of the system runs off the internal high-speed oscillator with gating from a slower game clock as well as move inputs (detailed later). A synchronization module is used to load a new frame from the gamestate logic when VGA and game logic have both declared they are ready for a new frame.\n\n\nVGA Timing Generator\nA parameterized VGA controller (e.g., vga_pkg::VGA_640x480_60) generates hsync, vsync, and (x, y) pixel coordinates for each active pixel. The controller:\n\nEncodes the full VGA timing (visible region, front/back porch, sync pulse).\nCan be reparameterized for other resolutions by changing a single configuration record.\n\n\n\nTetris Game Logic\nThe core game hardware includes:\n\nPiece State Machine Tracks the active tetromino‚Äôs type, rotation state, and (x, y) position. It advances in response to:\n\nGravity ticks (drop timer).\nLeft/right and movement commands (triggered upon receiving SPI transaction).\nRotation commands (triggered upon receiving SPI transaction).\n\nCollision Detection Uses the current board representation and a series of shifted piece masks to detect collisions with:\n\nWalls and floor.\nExisting locked blocks.\n\nMoves and rotations are only committed if they result in a legal position.\nLine-Clear Detection and Board Update Each frame, the hardware scans board rows to detect any that are fully occupied. When a full row is found:\n\nA clearing_line signal is asserted.\nThe row is cleared, and rows above shift downward (one row per update in the current design).\nThe score and line counters are updated accordingly.\n\nLoss Condition and Reset If a new piece cannot be placed (because blocks already occupy its spawn region), the system enters a loss state. A reset command (from the MCU over SPI or from a dedicated key) clears the board and restarts the game.\n\n\n\nBoard Representation & Blitting\nThe game board is stored as a 2D grid (e.g., 10 columns √ó 20 rows). Supporting modules include:\n\npiece_mask_generator: computes a local 6√ó6 window around the active piece, providing convenient access for boundary checks and neighborhood-based logic.\nblit_piece: overlays the active tetromino onto the fixed board state, computing board indices for each block in the 4√ó4 piece grid and combining them with the base state using simple bitwise operations.\n\nThis separation between fixed board and active piece enables clean rendering and simplifies the line-clear logic.\n\n\nInput Handling (PS/2 Keyboard)\nA PS/2 decoder samples the keyboard clock and data lines, decodes scan codes, and maps them to game commands:\n\nLeft / Right movement\nRotation\n\nThe decoder outputs debounced, single-cycle command pulses that the game state machine consumes, ensuring responsive but glitch-free behavior.\n\n\nTelemetry and Debug Overlay\nA telemetry_module renders text or numeric values into a reserved region of the screen. Internally the module converts these values into characters and overlays them after the game board is drawn, without affecting the board‚Äôs underlying representation.\nThis hardware overlay is extremely helpful for debugging timing issues and verifying state transitions.\n\n\nSchematics and Block Diagram\n\nFPGA dev board power and IO pin assignments.\nMCU dev board connections.\nSPI, PS/2, and VGA connectors with signal names and reference designators.\nAny custom IO or adapter boards used.\n\n  ‚Äì&gt;"
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#bill-of-materials-bom",
    "href": "E155-Portfolio/portfolio/portfolio.html#bill-of-materials-bom",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Bill of Materials (BOM)",
    "text": "Bill of Materials (BOM)\nThe table below lists the main hardware components used in the MicroPs system. Fill in the rows with your exact parts, quantities, and prices.\n\n\n\n\n\n\n\n\n\nItem / RefDes\nDescription\nQty\nUnit Price (USD)\n\n\n\n\nU1\nFPGA development board\n1\n-\n\n\nU2\nMicrocontroller development board\n1\n-\n\n\nJ1\nVGA connector (HD-15)\n1\n14.26\n\n\nJ2\nPS/2 connector\n1\n9.36\n\n\n-\nPs2 Keyboard\n1\n(Stockroom)\n\n\n-\nVGA display\n1\n(Stockroom)\n\n\n\nTotal project cost: 23.62"
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#new-hardware",
    "href": "E155-Portfolio/portfolio/portfolio.html#new-hardware",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "New Hardware",
    "text": "New Hardware\n\nRTL Hardware Modules\nIn addition to the material covered in class, the project includes several new hardware modules:\n\nCustom SPI Core (spi)\n\nImplements an SPI slave interface tuned to the MCU‚Äôs clock rate and protocol.\nIncludes parity or simple error checking before committing incoming data to registers.\nExposes clean status and data-valid flags to the game logic.\n\nPiece Mask Generator (piece_mask_generator)\n\nGenerates a 6√ó6 neighborhood window around the active piece, clamping out-of-bounds accesses.\nSimplifies collision and boundary logic while remaining synthesizable and efficient.\n\nBlit Piece (blit_piece)\n\nComputes the board indices for each block in the 4√ó4 tetromino grid.\nOverlays the active piece onto the static board state using logical operations, producing the rendered board for VGA.\n\nLine Clear Logic\n\nDetects full lines using row-wise reductions and asserts clearing_line.\nShifts rows above a cleared row downward, one row per update cycle in the project‚Äôs implementation.\nDesigned to be efficient and friendly to synthesis (using enables instead of large mux trees).\n\nTelemetry Overlay (telemetry_module)\n\nParameterized in number of signals and bit-width.\nRenders debug information directly into the frame, making it easy to observe internal state without a logic analyzer.\n\n\n\n\nNew Physical Hardware\nOn the FPGA side, we extended the baseline course design by integrating the on-chip low-speed oscillator and a hardware PLL to generate a stable pixel clock for VGA output. This required configuring new clocking resources, managing clock domains, and verifying that the timing met VGA 640√ó480 @ 60 Hz requirements. We then routed these signals through custom VGA timing and pixel-generation modules to drive an external VGA display, which introduced a completely new output format compared to the standard lab exercises.\nOn the microcontroller side, we implemented two major features beyond the core course content: an internal hardware-based random source and a PS/2 keyboard interface. The internal random generator is used to provide non-deterministic, hardware-driven piece generation for the Tetris game, while the PS/2 interface allowed us to accept real-time player input using a standard PS/2 keyboard. Both of these features required new peripheral configuration, custom protocols, and additional firmware modules that go beyond the standard course material."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#functional-results",
    "href": "E155-Portfolio/portfolio/portfolio.html#functional-results",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Functional Results",
    "text": "Functional Results\nThe system achieves the core functional requirements of a Tetris-style game:\n\nHardware random from MCU New pieces are chosen based on MCU-generated randomness, avoiding obvious patterns.\nHardware PLL from FPGA The VGA pixel clock is generated by the FPGA‚Äôs PLL, producing a stable 640√ó480@60 Hz signal.\nDisplay updates &gt; 20 Hz The display runs at 60 Hz, so the visible game update rate is comfortably above the 20 Hz requirement.\nNo visible flicker or ghosting The design uses a consistent board representation and clean overlay of the active piece, so the display does not flicker or ghost between frames.\nCorrect block behavior\n\nBlocks clear when a line is fully filled.\nLines above a cleared line shift downward.\nBlocks lower at a standard, controllable rate.\nNew random blocks appear once the previous block settles.\nGame boundaries stop pieces from moving outside the playfield.\n\nPlayer input and control\n\nThe player can move and rotate pieces using a PS/2 keyboard.\nCommands are decoded and applied on the appropriate clock edges.\nThe game resets correctly when the loss condition is triggered or when reset is commanded."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#quantitative-performance",
    "href": "E155-Portfolio/portfolio/portfolio.html#quantitative-performance",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Quantitative Performance",
    "text": "Quantitative Performance\nYou can fill in your actual numbers here once measured:\n\nFrame rate: 60 Hz VGA refresh (target).\nApproximate input-to-display latency: on the order of one frame period (dominated by the display).\nFPGA resource utilization:\n\nLUTs: 3861\nLUT Ripple: 74\nPFU Registers: 479\nIO Registers: 2\nIO Buffers: 11\n\nClock frequency of main game logic:\n\nHSOSC used as the global game logic flop clock at 48Mhz. Timing shows a slack of 5.809ns.\nThese metrics demonstrate that the design has comfortable timing margins, meets its refresh requirements, and fits within the available FPGA resources."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#design-tradeoffs-and-commentary",
    "href": "E155-Portfolio/portfolio/portfolio.html#design-tradeoffs-and-commentary",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Design Tradeoffs and Commentary",
    "text": "Design Tradeoffs and Commentary\nSeveral design decisions improved performance and clarity:\n\nSingle-clock-domain design with enables simplifies timing closure and avoids metastability issues.\nParameterized modules (e.g., board dimensions, number of telemetry signals, VGA parameters) make the design reusable for other games or resolutions.\nHardware-based line clear and score tracking eliminates the need for a software game loop, keeping the MCU simple and focused on randomness and control."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#team-members",
    "href": "E155-Portfolio/portfolio/portfolio.html#team-members",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Team Members",
    "text": "Team Members\n\nJames Kaden Cassidy\nApplied Mathematics in Computation, Harvey Mudd College Clay‚ÄìWolken Fellow, VLSI Lab\nKaden‚Äôs work centers on advancing open hardware. He is currently developing certification tests and hardware implementations of the RISC-V Vector Extension, contributing to the next generation of RISC-V processors.\nOutside of research, he is an athlete on the CMS Track & Field team, competing in the hammer, shot put, and discus.\nKaden is passionate about hardware/software co-design and seeks opportunities combining processor architecture, systems engineering, and algorithmic performance.\nüåê https://www.kadencassidy.com/\n\n\nNoah Fotenos\nEngineering, Harvey Mudd College Clay‚ÄìWolken Fellow, VLSI Lab\nNoah‚Äôs work centers on advancing open hardware. He is currently developing certification methodologies and verification test suite for the RISC-V Privilege Extensions, contributing to the next generation of RISC-V processors.\nOutside of research, he is an athlete on the Claremont Cougars club Lacrosse team. A Residential life Mentor for new students. A ‚ÄúMuchachief‚Äù leader for the Department of Student Life for oncampus events. And Grutor for E85 Computer Engineering."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#acknowledgements",
    "href": "E155-Portfolio/portfolio/portfolio.html#acknowledgements",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe gratefully acknowledge:\n\nCourse instructor and staff, for providing reference designs, lab infrastructure, and guidance on the MCU and FPGA toolchains.\nTeaching assistants and classmates, whose feedback and debugging assistance were invaluable, especially for clocking issues, PS/2 decoding, and synthesis quirks.\nOpen-source communities, whose documentation and example projects informed our VGA and PS2 interface(Ben Eater)."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#ai-usage",
    "href": "E155-Portfolio/portfolio/portfolio.html#ai-usage",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "AI Usage",
    "text": "AI Usage\nArtificial intelligence tools were used throughout the development of this project to support both hardware and software design tasks. AI was especially helpful during the implementation of the new PLL hardware module on the FPGA, where it accelerated debugging and clarified vendor-specific configuration details. It was also used extensively when writing and refining Verilog modules and their accompanying testbenches, as well as during the final cleanup of the microcontroller firmware.\nWhile AI was generally accurate when provided with complete and precise context, we found it most effective as a correctness amplifier‚Äîhelping verify logic, catch oversight errors, and suggest clearer structural patterns. As the project deadline approached and fatigue increased, we relied on AI to cross-check our reasoning and ensure that we were not introducing avoidable mistakes. Ultimately, AI served as a supplemental tool that improved workflow efficiency without replacing our judgment or engineering responsibilities."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#demo-video",
    "href": "E155-Portfolio/portfolio/portfolio.html#demo-video",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Demo Video",
    "text": "Demo Video\nA short video demonstrates the system running Tetris on the VGA display, showing:\n\nStable 640√ó480@60 Hz video.\nPiece motion, rotation, and line clears.\nHardware-generated random pieces and responsive keyboard control."
  },
  {
    "objectID": "E155-Portfolio/portfolio/portfolio.html#photos",
    "href": "E155-Portfolio/portfolio/portfolio.html#photos",
    "title": "Project Portfolio: Microcontroller‚ÄìFPGA Tetris System",
    "section": "Photos",
    "text": "Photos\nPhotos of the final design help document the hardware:\n\nFPGA board connected to the VGA monitor.\nMCU board with SPI connection to the FPGA.\nAny custom PCBs or wiring harnesses.\nClose-up of the VGA output showing the Tetris game."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Noah Fotenos is a Junior at Harvey Mudd College majoring in Engineering."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "MicroP Goals",
    "section": "",
    "text": "This semester my goal for E155 is deepen my knowledge in hardwear design. I have experience in digital design but feel like I havn‚Äôt been able to bring anything to the physical world. Additionally I am very excited for the final project and want to make something I can be really proad of."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab3",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nBuilding off lab2 7-Segment display circuit, The off board LED‚Äôs are replaced with the 4x4 matrix keypad with rows and outputs to and columns as inputs. Since the keyboard matrix works as switches connecting rows and columns to decode an input only one row can be powered at a time. Cycling through the rows waiting for a column input can be decoded for the specific key pressed. Once an input is detected a FSM as seen below is used to store the input, wait a period of about 100 ms to avoid D-bounce errors, wait for a release of the specific key ,and wait again for the release D-bounce.\n\n\n\nFigure 1: FSM design\n\n\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 160Hz to still be smooth to the eye without the display bleeding together while switching the row power fast enough to capture all inputs.\nTo test the design a Testbench for the 7-segment displays was already developed and tested in lab2.\nFirst checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Testbenches were made to check each submodule to very individual logic."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab3",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab3",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab3",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED‚Äôs without bleeding or visible oscillation or key-press glitches. This lab took around 15 hours."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab3",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file for the Monolithic design that did pass synthesis. I was super impressed by this because usually ai cant do large scale code. It did take longer than the past times but not by much at all. The code itself seems to use similiar high level logic to mine but the actual syntax is very different.\nThe modular prompts failed synthesis with many errors like unknown modules. So using the modular pompting I think the AI mixed its responses poorly. If I think both versions would require careful usage to work properly."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab5",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed calculate the RPM of a motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab5",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed calculate the RPM of a motor."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab5",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build uses header files from E-155 Git repository. This provided the macros and memory maps to use Flash, GPIO, USART, and RCC in the microcontroller. Pin A7 and A1 are set up as interrupt signals and the equations in figure 1 are used to calculate the RPS . Within the interrupt handlers first the signals of the motor encoder are checked then the signals are XOR‚Äôd to find the direction of the motor since for each encoder the XOR is either 1 or 0 depending on the relation to the other Encoder as seen in Figure 2. Depending on the direction the handler adds or subtracts a global counter to make show the # of edges. This gets converted to RPS.\nTo compare the ability of polling vs interrupts figure 3 shows the Osciliscope trace of a toggling pin from a polling loop. The frequency shows 600 hz but since this is alternating the actual polling as at 1.2 Khz. Using figure 4 the max RPM was calculated. To find the max interrups frequnecy a Frequency generator was connected to an interrupt pin and increased until behavior was incorrect."
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab5",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab5",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully calculated the RPS of the motor. this lab took about 10 hours."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab5",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT did very well with this. It used PA0 and PA1 and essentially did everything within the interrupts with the same logic. However it used macros from an #include I don‚Äôt know to set up the interrups. I was suprrised about how much background information it provided as well as context for its ideas instead of just suppling the code."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab6",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed read temperature through SPI and send it to a website using UART and HTML."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab6",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed read temperature through SPI and send it to a website using UART and HTML."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-and-testing-methodology",
    "href": "labs/lab6/lab6.html#design-and-testing-methodology",
    "title": "Lab6",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build uses header files from E-155 Git repository and Website starter. This provided the macros and memory maps to use Flash, GPIO, USART, RCC in the microcontroller, and code for turning on and off an LED with buttons on a website through wifi. To read temperature functions for initiating SPI, sending and receiving data, and configuration changes, were needed. The temperature sensor has configuration registers and 2 8 bit registers for the MSB of the the temperature data and 8 bits for the LSB which hold the fractional parts. SPI used 8 bit busses to transfer data needing 2 transactions to receive data one for accessing the relevant register and the second to read/write. both transactions are sandwiched by turning on and off the chip select to make one real transaction.\nTo understand the SPI signals the Logic Analyzer on the Osciliscope was used to read transactions as seen in figure 2 ## Technical Documentation:"
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab6",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully reads and displays temperature on the website with configurable resolution. this lab took about 15 hours."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype-summary",
    "href": "labs/lab6/lab6.html#ai-prototype-summary",
    "title": "Lab6",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\ntranscript link ChatGPT made a extremely large and complicated html file that I could not figure out how to put into my code. It did leave and notate an area to replace with my data information but was not applicable for this lab at all. I had function for the temperature retrieval and other helper functions. The html code worked and made a really cool website that does alot of things but seems to be making stuff up. The C code looked too simple and did not compile. It appears like it did not even try to initiate SPI nor set up a way to interact with the physical design."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab1",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nFor the hard wear the board was soldered in accordance to the E155 lab1 instructions. The resistor values for the 7-Segment display were derived from the Datasheet. Providing a 5v power supply from the board and a 2.1V drop across the diode with an If of 20mA using V=IR a resistor of 220ohms was used. For Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down so that the blinking frequency could be easily visualized using one of the on-board LEDs. The combinational logic for LED‚Äôs and 7-segment display were taking from the E155 specifications and truth table.\nTo test the design a Testbench was made to read a text file of test vectors describing all possible inputs and expected outputs. In simulation the Testbench reads the test file and compares to the DUT which is the top module implementing the above design. To confirm the oscillation an oscilloscope was used to show the frequency at which the LED is blinking."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab1",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab1",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab1",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator as well as displayed all Hexidecimal representation of a 4-bit input from onboard switches along with 2 gate controlled onboard LEDs. This lab took around 8 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab1",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was very fast to generate the entire Verilog module with ‚ÄúInternal HFOSC instantiation‚Äù and ‚ÄúBlink counter‚Äù code blocks. However the code failed do to miss instantiating the HFOSC writing ‚ÄúSB_HFOSC‚Äù. I was impressed that it went beyond the prompt and warned about if the led is pull down or not: ‚ÄúIf your LED is active-low, just change the toggle line to led &lt;= ~led; starting from led = 1‚Äôb1;‚Äù I thought this was surprising since it went into implementation. It also asked if I wanted to generate a testbench to run in simulation. I was impressed less by the code it generated but how usefull it would be as a partner for a larger scale project to provide help and extra information."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED‚Äôs showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED‚Äôs showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab2",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe resistor values for the 7-Segment displays and external LED‚Äôs were derived 220 \\(\\Omega\\). This was found by taking the the input voltage 3.3V minus Vce_sat (.2V) from the PNP transister DataSheet minus the 2.1V voltage drop across the LED to get 1V/220 \\(\\Omega\\) to get 4.5mA which is within the FPGA safe current. The external LED‚Äôs just lack the PNP voltage drop so is (3.3-2.1)/220 \\(\\Omega\\) to get 5.4mA which is also safe.\nThe resister for the PNP transister was picked targeting a 7.4mA from a 3.3v minus the Vbe_sat saturation voltage from base to emitter .85V to get 2.45V/330 \\(\\Omega\\) to be enough to activate the transister and be safe for the FPGA\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 80Hz to be inviable to the eye without the display bleeding together.\nTo test the design a Testbench for the 7-segment display was already developed and tested in lab1. Another Testbench was used to verify the counter module for the internal oscillator using assert statements checking the reset low pushes 0 into the counter as well as on the first clock the correct 28 is added to the counter, then waiting for the most significant bit to go high when anticipated. The top level module also uses assert statements to confirm all components work as intended. First checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Then to confirm the oscillation period waiting the half period of 3.125*e^9 pico seconds to confirm the 8Hz frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab2",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab2",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED‚Äôs and sum LEDs without bleeding or visible oscillation. There was a strange bug that with a specific combination of pins were set the led would get disrupted even though the logic was sound and was fixed with a capacitor to one of the I/O pins. If I had more time I would like to find the true source of this bug. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab2",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file but had difficulty calling the other modules correctly. To me the code it generated was much more complicated than it needed to be using syntax I am unfamiliar with. The code is logically sound after inspection but did not synthesize first try. I think if I were to work with this code for a bit I could get it working much faster than it took me."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab4",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build largely based off of the starter code from from the E-155 Git repository. This provided the macros and memory maps to use Flash, GPIO, and RCC in the microntroller. To utilize TIM15 and TIM16 a header-file with the register map layout at the correct memory was made to reference and active the proper outputs. To get notes to play 3 function were made en15_16_APB(), wait and PWM. The en15_16_APB() functions instantiates the needed path so TIM15 and TIM16 get the system clock at 80Mhz. The wait function using TIM15 is used for the duration of notes or pauses and utilizes the a set prescaler at 799 to divide the clock to 1000hz then sets the ARR register value to the inputed milliseconds times 100 to be in the right unit of hertz. There is a while loop waiting for the ARR overflow bit is set once the wait time has past. The PWM function sets TIM16 to a desired frequency. It does this by first cheking if the frequency is 0 to freeze the system and avoid divide by 0 issues. Then divides 80Mhz by the desired frequency into a temp variable to see if only ARR is needed if the value is to large past the 16 bit register size it divides the temp variable by 2 and multiplies the prescaler by 2 until it can fit into ARR. The main function instatiates the all the macros and houses the song frequency and duration tables. The main function then goes through the table inputing into the wait and PWM function to play the songs.\nTo test the system calculations for maximum and minimum frequency and wait times were calculated as well as the expected error in output frequency as seen below."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab4",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab4",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully played Fur Elise and the ice cream truck song. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab4",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT Chose to use TIM2 instead of TIM15 TIM16. The calculations all looked good. The registers it chose look correct although I didn‚Äôt use TIM2. I am surprised how well it responded with needed info. I also asked it for code which it did, it seems like the the register instantiation looked good but I didn‚Äôt try uploading it."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "E155-Portfolio/proposal/proposal.html",
    "href": "E155-Portfolio/proposal/proposal.html",
    "title": "Hardware Tetris Project Proposal",
    "section": "",
    "text": "Project Description and Overview\nOur project implements the classic game Tetris directly in hardware using an FPGA as the game engine and a microcontroller (MCU) as a peripheral co-processor. The FPGA handles core game logic and VGA display output, while the MCU manages higher-level logic such as random block generation and controller input translation.\nWe plan to leverage the FPGA for deterministic, processing of visual and game logic while using the MCU for tasks that benefit from flexibility, such as pseudo-random number generation and USB input handling.\nGameplay will be displayed on a VGA monitor at refresh rates exceeding 20 Hz with no flicker or ghosting. The FPGA‚Äôs internal memory will maintain the game state and render directly to VGA timing signals. The MCU will periodically supply the FPGA with new pieces and player inputs over a bus interface.\n\n\n\nFigure 1: Block Diagram with all electrical components\n\n\n\n\n\nProficiency Goals\n\nDisplay updates at &gt;20 Hz\n\nBlocks clear at completed lines and update correctly\n\nBlocks fall at standard rate\n\nNew random blocks appear once the previous block settles\n\nGame boundaries prevent invalid movement\n\nNo visibly obvious gameplay bugs\n\nPlayer can control piece movement with button input\n\nBlocks move left and right\n\n\n\n\nExcellency Goals\n\nGame speeds up progressively\n\nUSB controller used to play game\n\nBlock rotation implemented\n\nController operates in ‚Äúarcade mode‚Äù\n\nHard drop implemented\n\nNext piece preview displayed\n\n\n\n\nFPGA Design Details\nThe FPGA implements a hardware Tetris engine consisting of the following modules:\n\nVGA Controller\nGenerates 800x600 @ 60 Hz timing signals and color data from block map memory.\n\n\nBlock Map Memory\nGame data stored in on-chip SRAM.\n\n\nPiece Logic\nDetermines piece movement, collision detection, and line clears for each frame.\n\n\nFSM Game Controller\nControls falling timing, piece locking, and score tracking.\n\n\nMCU Interface Module\nImplements a simple SPI interface to receive player inputs (left, right, rotate, drop) and new piece identifiers from the MCU.\n\n\nClocking & Timing\nUses a 80 MHz system clock for VGA synchronization and deterministic updates at &gt;20 Hz refresh rate.\n\n\n\n\nMCU Design Details\nThe MCU acts as an intelligent peripheral, responsible for higher-level coordination:\n\nRandom Piece Generation\nImplements a pseudo-random sequence ensuring fair block distribution.\n\n\nController Interface\nReads inputs from buttons or a USB gamepad and translates them into movement commands.\n\n\nCommunication Bridge\nUses SPI or UART to send player inputs and new-piece data to the FPGA.\n\n\nProgression Logic (Excellency)\nOptionally increases drop speed, handles ‚Äúarcade mode,‚Äù and shows the ‚Äúnext piece‚Äù preview by pre-sending upcoming block data.\nA small task loop coordinates controller input polling and data buffering.\nAn interrupt will be used to request data from the MCU.\n\n\n\n\nBudget\n\n\n\nItem\nQuantity\nCost\nNotes\n\n\n\n\nVGA Breakout\n1√ó\n$14.26\nPurchased\n\n\nGameCube Controller\n1√ó\n$12.00\nPurchased\n\n\nTotal\n‚Äî\n$26.26\n\n\n\nSTM32 Nucleo-32 MCU\n1√ó\nHave\n\n\n\nUPduino iCE40 FPGA\n1√ó\nHave\n\n\n\n1000 ft Wire\n1√ó\nStockroom\n\n\n\nVGA Display\n1√ó\nBorrowed (Xavier)\n\n\n\n\n\n\n\nCalculations\n\nSVGA requires 40 MHz for 800√ó600.\nThe FPGA will divide the clock by 2 to achieve standard timing.\n\n\n\n\nSchedule\n\n\n\nWeek\nTask\nHours\nLead\n\n\n\n\n1 (Start 10/27)\nProject demo setup\n2 h\nBoth\n\n\n\nVGA implementation\n15 h +\nKaden\n\n\n\nMCU‚ÄìFPGA link\n4 h +\nNoah\n\n\n2\nFPGA game shifter\n10 h +\nNoah\n\n\n\nMCU randomization + USB logic\n10 h +\nKaden\n\n\n3\nFinish game (Proficiency demo)\n3 h +\nBoth\n\n\n\nDemo presentation\n2 h +\nBoth\n\n\n4\nBegin Excellency work\n5 h +\nBoth\n\n\n5\nDebug\n10 h +\nBoth\n\n\n\nFinal presentation\n2 h +\nBoth\n\n\n\n\n\n\nWork Distribution\nWe plan on distributing work within each project aspect. Most of the time, we will work together in the lab; however, for aspects more appropriate for individual focus, we will assign tasks based on each member‚Äôs strengths and experience."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to E155 Website"
  }
]