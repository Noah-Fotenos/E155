[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "MicroP Goals\n\n\nBroadly what I want to achieve from E155\n\n\n\n\n\nAug 29, 2025\n\n\nNoah Fotenos\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Noah Fotenos is a Junior at Harvey Mudd College majoring in Engineering."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "MicroP Goals",
    "section": "",
    "text": "This semester my goal for E155 is deepen my knowledge in hardwear design. I have experience in digital design but feel like I havn’t been able to bring anything to the physical world. Additionally I am very excited for the final project and want to make something I can be really proad of."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab3",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by a 4x4 matrix keypad. On a key press the right LED displays the input and a new press, updates and pushes the past number to the right display. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab3",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nBuilding off lab2 7-Segment display circuit, The off board LED’s are replaced with the 4x4 matrix keypad with rows and outputs to and columns as inputs. Since the keyboard matrix works as switches connecting rows and columns to decode an input only one row can be powered at a time. Cycling through the rows waiting for a column input can be decoded for the specific key pressed. Once an input is detected a FSM as seen below is used to store the input, wait a period of about 100 ms to avoid D-bounce errors, wait for a release of the specific key ,and wait again for the release D-bounce.\n\n\n\nFigure 1: FSM design\n\n\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 160Hz to still be smooth to the eye without the display bleeding together while switching the row power fast enough to capture all inputs.\nTo test the design a Testbench for the 7-segment displays was already developed and tested in lab2.\nFirst checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Testbenches were made to check each submodule to very individual logic."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab3",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab3",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab3",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED’s without bleeding or visible oscillation or key-press glitches. This lab took around 15 hours."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab3",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file for the Monolithic design that did pass synthesis. I was super impressed by this because usually ai cant do large scale code. It did take longer than the past times but not by much at all. The code itself seems to use similiar high level logic to mine but the actual syntax is very different.\nThe modular prompts failed synthesis with many errors like unknown modules. So using the modular pompting I think the AI mixed its responses poorly. If I think both versions would require careful usage to work properly."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab1",
    "section": "",
    "text": "In this lab, a development board was assembled to house a UPduino v3.1 FPGA and a Nucleo-L432KC microcontroller. To test the board a design to control a 7 segment display and 3 onboard LEDs was implemented. The 7-segment display and 2 of the onboard LEDs were controlled with combinational logic from a 4 switch input and the third LED was to demonstrate the functionality of the on-board high-speed oscillator by blinking one of the on-board LEDs. The high speed oscillator was configured at a frequency of 48 MHz and divided down using a counter to achieve a blinking frequency of ~2.4 Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab1",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nFor the hard wear the board was soldered in accordance to the E155 lab1 instructions. The resistor values for the 7-Segment display were derived from the Datasheet. Providing a 5v power supply from the board and a 2.1V drop across the diode with an If of 20mA using V=IR a resistor of 220ohms was used. For Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down so that the blinking frequency could be easily visualized using one of the on-board LEDs. The combinational logic for LED’s and 7-segment display were taking from the E155 specifications and truth table.\nTo test the design a Testbench was made to read a text file of test vectors describing all possible inputs and expected outputs. In simulation the Testbench reads the test file and compares to the DUT which is the top module implementing the above design. To confirm the oscillation an oscilloscope was used to show the frequency at which the LED is blinking."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab1",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab1",
    "section": "Results and Discussion:",
    "text": "Results and Discussion:"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab1",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully blinked an external LED using the on-board high-speed oscillator as well as displayed all Hexidecimal representation of a 4-bit input from onboard switches along with 2 gate controlled onboard LEDs. This lab took around 8 hours."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab1",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was very fast to generate the entire Verilog module with “Internal HFOSC instantiation” and “Blink counter” code blocks. However the code failed do to miss instantiating the HFOSC writing “SB_HFOSC”. I was impressed that it went beyond the prompt and warned about if the led is pull down or not: “If your LED is active-low, just change the toggle line to led &lt;= ~led; starting from led = 1’b1;” I thought this was surprising since it went into implementation. It also asked if I wanted to generate a testbench to run in simulation. I was impressed less by the code it generated but how usefull it would be as a partner for a larger scale project to provide help and extra information."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED’s showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab2",
    "section": "",
    "text": "In this lab, UPduino v3.1 FPGA is programmed to display 2 7-segment displays controlled by 2 4-input DIP-switches as well as 5 external LED’s showing the sum in binary of the 2 4-bit inputs. Due to the power draw of the 7-segment displays the FPGA can only power one at a time therefor time multiplexing at 80Hz to alternate the anodes of the dual 7-segment displays using PNP transistors."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab2",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe resistor values for the 7-Segment displays and external LED’s were derived 220 \\(\\Omega\\). This was found by taking the the input voltage 3.3V minus Vce_sat (.2V) from the PNP transister DataSheet minus the 2.1V voltage drop across the LED to get 1V/220 \\(\\Omega\\) to get 4.5mA which is within the FPGA safe current. The external LED’s just lack the PNP voltage drop so is (3.3-2.1)/220 \\(\\Omega\\) to get 5.4mA which is also safe.\nThe resister for the PNP transister was picked targeting a 7.4mA from a 3.3v minus the Vbe_sat saturation voltage from base to emitter .85V to get 2.45V/330 \\(\\Omega\\) to be enough to activate the transister and be safe for the FPGA\nFor Digital methodology the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 80Hz to be inviable to the eye without the display bleeding together.\nTo test the design a Testbench for the 7-segment display was already developed and tested in lab1. Another Testbench was used to verify the counter module for the internal oscillator using assert statements checking the reset low pushes 0 into the counter as well as on the first clock the correct 28 is added to the counter, then waiting for the most significant bit to go high when anticipated. The top level module also uses assert statements to confirm all components work as intended. First checking initial conditions after reset with the adder and segment displays. then while only one anode is on checking a combination of inputs to confirm the LED adder and the 7-segment display output. Then to confirm the oscillation period waiting the half period of 3.125*e^9 pico seconds to confirm the 8Hz frequency."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab2",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab2",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully displayed both 7-segment LED’s and sum LEDs without bleeding or visible oscillation. There was a strange bug that with a specific combination of pins were set the led would get disrupted even though the logic was sound and was fixed with a capacitor to one of the I/O pins. If I had more time I would like to find the true source of this bug. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab2",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT was able to generate a large file but had difficulty calling the other modules correctly. To me the code it generated was much more complicated than it needed to be using syntax I am unfamiliar with. The code is logically sound after inspection but did not synthesize first try. I think if I were to work with this code for a bit I could get it working much faster than it took me."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab4",
    "section": "",
    "text": "In this lab, a Nucleo-L432KC micro-controller is programmed to play 2 songs on a LM386 low power speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab4",
    "section": "Design and Testing Methodology:",
    "text": "Design and Testing Methodology:\nThe design of this lab was build largely based off of the starter code from from the E-155 Git repository. This provided the macros and memory maps to use Flash, GPIO, and RCC in the microntroller. To utilize TIM15 and TIM16 a header-file with the register map layout at the correct memory was made to reference and active the proper outputs. To get notes to play 3 function were made en15_16_APB(), wait and PWM. The en15_16_APB() functions instantiates the needed path so TIM15 and TIM16 get the system clock at 80Mhz. The wait function using TIM15 is used for the duration of notes or pauses and utilizes the a set prescaler at 799 to divide the clock to 1000hz then sets the ARR register value to the inputed milliseconds times 100 to be in the right unit of hertz. There is a while loop waiting for the ARR overflow bit is set once the wait time has past. The PWM function sets TIM16 to a desired frequency. It does this by first cheking if the frequency is 0 to freeze the system and avoid divide by 0 issues. Then divides 80Mhz by the desired frequency into a temp variable to see if only ARR is needed if the value is to large past the 16 bit register size it divides the temp variable by 2 and multiplies the prescaler by 2 until it can fit into ARR. The main function instatiates the all the macros and houses the song frequency and duration tables. The main function then goes through the table inputing into the wait and PWM function to play the songs.\nTo test the system calculations for maximum and minimum frequency and wait times were calculated as well as the expected error in output frequency as seen below."
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab4",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:"
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab4",
    "section": "Conclusion",
    "text": "Conclusion\nThe design successfully played Fur Elise and the ice cream truck song. This lab took around 10 hours."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab4",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\nChatGPT Chose to use TIM2 instead of TIM15 TIM16. The calculations all looked good. The registers it chose look correct although I didn’t use TIM2. I am suprised how well it responded with needed info. I also asked it for code which it did, it seems like the the register instantiation looked good but I didn’t try uploading it."
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Link to E155 Website"
  }
]